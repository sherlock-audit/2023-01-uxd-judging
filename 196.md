peanuts

high

# Anyone can call PerpDepository.rebalance()

## Summary

The protocol uses a delta neutral strategy to keep the collateral price in check. If the price of the collateral, eg ETH, falls, the protocol can rebalance its asset amount through a series of withdrawal and deposit because of the protocol's shorting strategy. However, anyone can call the rebalance function. A malicious user can call rebalance on an account many times to waste unnecessary fees.

## Vulnerability Detail

When a user's collateral experience a downfall, the protocol can execute rebalancing to keep the collateral price in check. The function rebalance() calls _rebalanceNegativePnlWithSwap(),

    function rebalance(
        uint256 amount,
        uint256 amountOutMinimum,
        uint160 sqrtPriceLimitX96,
        uint24 swapPoolFee,
        int8 polarity,
        address account
    ) external nonReentrant returns (uint256, uint256) {
        if (polarity == -1) {
            return
                _rebalanceNegativePnlWithSwap(
                    amount,
                    amountOutMinimum,
                    sqrtPriceLimitX96,
                    swapPoolFee,
                    account
                );
        } else if (polarity == 1) {
            // disable rebalancing positive PnL
            revert PositivePnlRebalanceDisabled(msg.sender);
            // return _rebalancePositivePnlWithSwap(amount, amountOutMinimum, sqrtPriceLimitX96, swapPoolFee, account);
        } else {
            revert InvalidRebalance(polarity);
        }
    }

which executes vault.withdraw and vault.deposit. In between withdraw and deposit, the account has to pay a small amount of fee to execute a swap function.

        vault.withdraw(assetToken, baseAmount);
        SwapParams memory params = SwapParams({
            tokenIn: assetToken,
            tokenOut: quoteToken,
            amountIn: baseAmount,
            amountOutMinimum: amountOutMinimum,
            sqrtPriceLimitX96: sqrtPriceLimitX96,
            poolFee: swapPoolFee
        });
        uint256 quoteAmountOut = spotSwapper.swapExactInput(params);
        int256 shortFall = int256(
            quoteAmount.fromDecimalToDecimal(18, ERC20(quoteToken).decimals())
        ) - int256(quoteAmountOut);
        if (shortFall > 0) {
            IERC20(quoteToken).transferFrom(
                account,
                address(this),
                uint256(shortFall)
            );
        } else if (shortFall < 0) {
            // we got excess tokens in the spot swap. Send them to the account paying for rebalance
            IERC20(quoteToken).transfer(
                account,
                _abs(shortFall)
            );
        }
        vault.deposit(quoteToken, quoteAmount);

## Impact

A malicious user can execute rebalance() continuously to drain the user funds by having him pay the swap fees over and over again.

## Code Snippet

https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L446-L470

https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L498-L524

## Tool used

Manual Review

## Recommendation

Introduce a modifier to the rebalance() function so that only verified people can call the function.